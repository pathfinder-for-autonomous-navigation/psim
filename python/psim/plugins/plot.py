"""Data driven plotting utility consisting of a pluging and small set of helper
classes.
"""

from psim.plugins import Plugin
from psim.utilities import get_plotting_files

from matplotlib import pyplot as plt

import logging
import numpy as np
import yaml

log = logging.getLogger(__name__)


class Plot(object):
    """Base class for all other plot types that can be generated by the plotting
    utility.
    """
    def __init__(self, **kwargs):
        super(Plot, self).__init__()

        self._arrays = set()
    
    @staticmethod
    def _mangle_array(array):
        """Returns the field name corresponding to any array name. Essentially,
        this means the '.x', '.y', '.z', or '.w' suffix is stripped.
        """
        return array[:-2] if array.endswith('.x') or array.endswith('.y') or \
                             array.endswith('.z') or array.endswith('.w') else \
                             array

    @property
    def arrays(self):
        """Retrieves a set of strings representing the data arrays this plot
        requires.
        """
        return self._arrays
    
    def plot(self, arrays):
        """Displays the plot.
        """
        pass


class Plot2D(Plot):

    def __init__(self, x=None, y=None, **kwargs):
        super(Plot2D, self).__init__(**kwargs)

        if not x or not y:
            raise RuntimeError('A 2D plot requires "x" and "y" arguments.')

        self._x = x
        self._y = y if type(y) is list else [y]

        self._arrays = set(self._y).union({self._x})
    
    def plot(self, arrays):
        super(Plot2D, self).plot(arrays)

        fg = plt.figure()
        ax = fg.add_subplot(111)
        for _y in self._y:
            ax.plot(arrays[self._x], arrays[_y], label=_y)
        ax.legend()
        ax.set_xlabel(self._x)
        fg.show()


class Plot2DLog(Plot2D):

    def __init__(self, **kwargs):
        super(Plot2DLog, self).__init__(**kwargs)
    
    def plot(self, arrays):
        super(Plot2D, self).plot(arrays)

        fg = plt.figure()
        ax = fg.add_subplot(111)
        ax.set(yscale='log')
        for _y in self._y:
            ax.plot(arrays[self._x], arrays[_y], label=_y)
        ax.legend()
        ax.set_xlabel(self._x)
        fg.show()


class Plot3D(Plot):

    def __init__(self, x=None, y=None, z=None, **kwargs):
        super(Plot3D, self).__init__(**kwargs)

        if not x or not y or not z:
            raise RuntimeError('A 3D plot requires "x", "y", and "z" arguments.')

        self._x = x
        self._y = y
        self._z = z if type(z) is list else [z]

        self._arrays = set(self._z).union({self._x, self._y})

    def plot(self, arrays):
        super(Plot3D, self).plot(arrays)

        fg = plt.figure()
        ax = fg.add_subplot(111, projection='3d')
        for _z in self._z:
            ax.plot(arrays[self._x], arrays[self._y], arrays[_z], label=_z)
        ax.legend()
        ax.set_xlabel(self._x)
        ax.set_ylabel(self._y)
        fg.show()


class PlotEstimate(Plot):

    def __init__(self, x=None, y=None, **kwargs):
        super(PlotEstimate, self).__init__(**kwargs)

        if not x or not y:
            raise RuntimeError('An estimate plot requires "x" and "y" arguments.')

        self._x = x
        self._y = y

        if self._y.endswith('.x') or self._y.endswith('.y') or \
                self._y.endswith('.z') or self._y.endswith('.w'):
            self._e = self._y[:-2] + ".error" + self._y[-2:]
            self._s = self._y[:-2] + ".sigma" + self._y[-2:]
        else:
            self._e = self._y + ".error"
            self._s = self._y + ".sigma"

        self._arrays.add(self._x)
        self._arrays.add(self._e)
        self._arrays.add(self._s)

    def plot(self, arrays):
        super(PlotEstimate, self).plot(arrays)

        fg = plt.figure()
        ax = fg.add_subplot(111)
        ax.plot(arrays[self._x], arrays[self._e], 'b-', label=self._e)
        ax.plot(arrays[self._x], 2.0*np.array(arrays[self._s]), 'g:', label='two sigma bounds')
        ax.plot(arrays[self._x], -2.0*np.array(arrays[self._s]), 'g:')
        ax.legend()
        ax.set_xlabel(self._x)
        fg.show()


class Plotter(Plugin):
    """Logs telemetry to display in a set of plots upon simulation termination.
    """
    def __init__(self, plots=None, step=1):
        super(Plotter, self).__init__()

        self._plots = plots if not plots or type(plots) == list else [plots]
        self._step = step
        self._n = 0

    def arguments(self, parser):
        super(Plotter, self).arguments(parser)

        _plots_default = self._plots if not self._plots else ','.join(self._plots)
        parser.add_argument(
            '-p', '--plots', type = str, default = _plots_default,
            help = 'comma separated list of plotting files used to log and ' +
            'plot data over the course of the simulation'
        )
        parser.add_argument(
            '-ps', '--plots-step', type = int, default = self._step,
            help = 'step interval at which data is recorded for plotting'
        )

    def initialize(self, sim, args):
        """Parses the plotting configuration files and determines what state
        fields must be logged during the simulation.
        """
        super(Plotter, self).initialize(sim, args)

        def _stream_plots(plots):
            """Generates plot objects from a list of configuration dictionaries.
            """
            for plot in plots:
                with open(plot, 'r') as istream:
                    _plots = yaml.safe_load(istream)
                    for _plot in _plots if type(_plots) == list else [_plots]:
                        if _plot['type'] == 'Plot2D':
                            yield Plot2D(**_plot)
                        elif _plot['type'] == 'Plot2DLog':
                            yield Plot2DLog(**_plot)
                        elif _plot['type'] == 'Plot3D':
                            yield Plot3D(**_plot)
                        elif _plot['type'] == 'PlotEstimate':
                            yield PlotEstimate(**_plot)

        if not args.plots:
            log.warning('No plots specified via the command line; defaulting to %s.', str(self._plots))
        else:
            self._plots = args.plots.split(',')
            log.info('Overriding plots via the command line to %s', self._plots)

        _plots_files = get_plotting_files(self._plots)
        log.debug('Loading plots from the following configuration files: %s', _plots_files)
        self._plots = [plot for plot in _stream_plots(_plots_files)]

        self._fields = dict()
        for _plot in self._plots:
            for _array in _plot.arrays:
                _field = Plot._mangle_array(_array)
                if not self._fields.get(_field, None):
                    self._fields[_field] = list()

    def poststep(self, sim):
        """Periodically logs the necessary fields for plotting upon termination
        of the simulation.
        """
        super(Plotter, self).poststep(sim)

        self._n = self._n + 1
        if self._step > 0 and self._n % self._step == 0:
            self._n = 0
            for k, v in self._fields.items():
                v.append(sim[k])

    def cleanup(self, sim):
        super(Plotter, self).cleanup(sim)

        # Ignore plots if the step was set to zero
        if not self._step > 0:
            log.warning('Skipping plotting because the plot step wasn\'t greater than zero')
            return

        log.info('Generating plots...')

        # Generate direct data arrays for plotting
        arrays = dict()
        for _arrays in [plot.arrays for plot in self._plots]:
            for _array in _arrays:
                if not arrays.get(_array, None):
                    if _array.endswith('.x'):
                        arrays[_array] = [x[0] for x in self._fields[Plot._mangle_array(_array)]]
                    elif _array.endswith('.y'):
                        arrays[_array] = [y[1] for y in self._fields[Plot._mangle_array(_array)]]
                    elif _array.endswith('.z'):
                        arrays[_array] = [z[2] for z in self._fields[Plot._mangle_array(_array)]]
                    elif _array.endswith('.w'):
                        arrays[_array] = [w[3] for w in self._fields[Plot._mangle_array(_array)]]
                    else:
                        arrays[_array] = [u for u in self._fields[Plot._mangle_array(_array)]]

        # Dump the logged fields
        del self._fields

        # Loop through plots
        for plot in self._plots:
            plot.plot(arrays)

        # Block on user input
        log.info('Plotting complete! Press [ENTER] to continue.')
        input()
